inherit_from: .rubocop_todo.yml

AllCops:
  DisplayCopNames: true
  DisplayStyleGuide: true
  TargetRubyVersion: 2.5
  Exclude:
    - 'vendor/**/*'
    - 'db/schema.rb'
    - 'bin/*'
    - 'node_modules/*'

Metrics/BlockLength:
  Exclude:
    - "spec/**/*"
    - "lib/**/*.rake"

Style/AsciiComments:
  Enabled: false

Bundler/OrderedGems:
  Enabled: false

Style/FrozenStringLiteralComment:
  Enabled: false

# Commonly used screens these days easily fit more than 80 characters.
Metrics/LineLength:
  Max: 100

# Too short methods lead to extraction of single-use methods, which can make
# the code easier to read (by naming things), but can also clutter the class
Metrics/MethodLength:
  Max: 20

# The guiding principle of classes is SRP, SRP can't be accurately measured by LoC
Metrics/ClassLength:
  Max: 1500

# We do not need to support Ruby 1.9, so this is good to use.
Style/SymbolArray:
  Enabled: true

# has_key? and has_value? are far more readable than key? and value?
Style/PreferredHashMethods:
  EnforcedStyle: verbose

# A specialized exception class will take one or more arguments and construct the message from it.
# So both variants make sense.
Style/RaiseArgs:
  Enabled: false

# Fail is an alias of raise. Avoid aliases, it's more cognitive load for no gain.
# The argument that fail should be used to abort the program is wrong too,
# there's Kernel#abort for that.
Style/SignalException:
  EnforcedStyle: only_raise

# Suppressing exceptions can be perfectly fine, and be it to avoid to
# explicitly type nil into the rescue since that's what you want to return,
# or suppressing LoadError for optional dependencies
Lint/HandleExceptions:
  Enabled: false

# do / end blocks should be used for side effects,
# methods that run a block for side effects and have
# a useful return value are rare, assign the return
# value to a local variable for those cases.
Style/MethodCalledOnDoEndBlock:
  Enabled: true

# Enforcing the names of variables? To single letter ones? Just no.
Style/SingleLineBlockParams:
  Enabled: false

# Shadowing outer local variables with block parameters is often useful
# to not reinvent a new name for the same thing, it highlights the relation
# between the outer variable and the parameter. The cases where it's actually
# confusing are rare, and usually bad for other reasons already, for example
# because the method is too long.
Lint/ShadowingOuterLocalVariable:
  Enabled: false

# Check with yard instead.
Style/Documentation:
  Enabled: false

# There are valid cases, for example debugging Cucumber steps,
# also they'll fail CI anyway
#Lint/Debugger:
#  Enabled: false
